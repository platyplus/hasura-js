/** Declaration file generated by dts-gen */
declare module 'sql-parser' {
  export function parse(sql: any): any

  export namespace lexer {
    function tokenize(sql: any, opts?: any): any
  }

  export namespace nodes {
    class ArgumentListValue {
      constructor(value: any, distinct: any)

      public toString(): any
    }

    class BooleanValue {
      constructor(value: any)

      public toString(): any
    }

    class Field {
      constructor(field: any, name: any)

      public toString(): any
    }

    class FunctionValue {
      public name: string
      constructor(name: any, _arguments: any, udf: any)
      public toString(): any
    }

    class Group {
      constructor(fields: any)

      public toString(): any
    }

    class Having {
      constructor(conditions: any)

      public toString(): any
    }

    class Join {
      constructor(right: any, conditions: any, side: any, mode: any)

      public toString(): any
    }

    class Limit {
      constructor(value: any, offset: any)

      public toString(): any
    }

    class ListValue {
      constructor(value: any)

      public toString(): any
    }

    class LiteralValue {
      public value: any
      constructor(value: any, value2: any)
      public toString(): any
    }

    class NumberValue {
      constructor(value: any)

      public toString(): any
    }

    class Offset {
      constructor(row_count: any, limit: any)

      public toString(): any
    }

    class Op {
      public left: Op
      public right: Op
      public operation: string
      constructor(operation: string, left: any, right: any)
      public toString(): any
    }

    class Order {
      constructor(orderings: any, offset: any)

      public toString(): any
    }

    class OrderArgument {
      constructor(value: any, direction: any)

      public toString(): any
    }

    class ParameterValue {
      constructor(value: any)

      public toString(): any
    }

    class Select {
      constructor(fields: any, source: any, distinct: any, joins: any, unions: any)

      public toString(): any
    }

    class Star {
      constructor()

      public toString(): any
    }

    class StringValue {
      constructor(value: any, quoteType: any)

      public toString(): any
    }

    class SubSelect {
      constructor(select: any, name: any)

      public toString(): any
    }

    class Table {
      constructor(name: any, alias: any, win: any, winFn: any, winArg: any)

      public toString(): any
    }

    class UnaryOp {
      constructor(operator: any, operand: any)

      public toString(): any
    }

    class Union {
      constructor(query: any, all: any)

      public toString(): any
    }

    class Where {
      constructor(conditions: any)

      public toString(): any
    }
  }

  export namespace parser {
    function parse(str: any): any

    namespace parser {
      class Parser {
        constructor()

        public Parser(): void

        public parse(input: any, ...args: any[]): any

        public parseError(str: any, hash: any): void

        public performAction(yytext: any, yyleng: any, yylineno: any, yy: any, yystate: any, $$: any, _$: any): any

        public trace(): void
      }

      const defaultActions: {
        '9': number[]
      }

      const productions_: number[]

      const symbols_: {
        $accept: number
        $end: number
        ALL: number
        AS: number
        AggregateArgumentList: number
        ArgumentList: number
        BOOLEAN: number
        BY: number
        BasicSelectQuery: number
        Boolean: number
        CONDITIONAL: number
        DBLSTRING: number
        DIRECTION: number
        DISTINCT: number
        DOT: number
        EOF: number
        Expression: number
        FETCH: number
        FIRST: number
        FROM: number
        FUNCTION: number
        FetchClause: number
        Field: number
        Fields: number
        Function: number
        GROUP: number
        GroupBasicClause: number
        GroupClause: number
        HAVING: number
        HavingClause: number
        INNER: number
        JOIN: number
        Join: number
        Joins: number
        LEFT: number
        LEFT_PAREN: number
        LIMIT: number
        LITERAL: number
        LimitClause: number
        List: number
        Literal: number
        MATH: number
        MATH_MULTI: number
        NEXT: number
        NUMBER: number
        Number: number
        OFFSET: number
        ON: number
        ONLY: number
        OPERATOR: number
        ORDER: number
        OUTER: number
        OffsetClause: number
        OffsetRows: number
        OrderArg: number
        OrderArgs: number
        OrderClause: number
        PARAMETER: number
        Parameter: number
        Query: number
        RIGHT: number
        RIGHT_PAREN: number
        ROW: number
        ROWS: number
        Root: number
        SELECT: number
        SEPARATOR: number
        STAR: number
        STRING: number
        SUB_SELECT_OP: number
        SUB_SELECT_UNARY_OP: number
        Select: number
        SelectClause: number
        SelectQuery: number
        SelectWithLimitQuery: number
        String: number
        SubSelectExpression: number
        Table: number
        UNION: number
        Union: number
        Unions: number
        UserFunction: number
        Value: number
        WHERE: number
        WINDOW: number
        WINDOW_FUNCTION: number
        WhereClause: number
        error: number
      }

      const table: Array<{
        '10': number
        '14': number
        '16': number[]
        '3': number
        '4': number
        '6': number
        '8': number
        '9': number
      }>

      const terminals_: {
        '16': string
        '18': string
        '2': string
        '20': string
        '23': string
        '24': string
        '26': string
        '27': string
        '28': string
        '31': string
        '32': string
        '34': string
        '35': string
        '37': string
        '38': string
        '39': string
        '40': string
        '41': string
        '42': string
        '43': string
        '44': string
        '45': string
        '46': string
        '5': string
        '51': string
        '54': string
        '55': string
        '56': string
        '57': string
        '58': string
        '59': string
        '62': string
        '64': string
        '65': string
        '66': string
        '67': string
        '68': string
        '69': string
        '71': string
        '77': string
        '78': string
        '79': string
        '80': string
        '81': string
        '82': string
        '83': string
        '84': string
        '87': string
      }

      function parse(input: any, ...args: any[]): any

      function parseError(str: any, hash: any): void

      function performAction(yytext: any, yyleng: any, yylineno: any, yy: any, yystate: any, $$: any, _$: any): any

      function trace(): void

      namespace lexer {
        function lex(): any

        function setInput(tokens: any): any

        function upcomingInput(): any
      }

      namespace yy {
        class ArgumentListValue {
          constructor(value: any, distinct: any)

          public toString(): any
        }

        class BooleanValue {
          constructor(value: any)

          public toString(): any
        }

        class Field {
          constructor(field: any, name: any)

          public toString(): any
        }

        class FunctionValue {
          constructor(name: any, _arguments: any, udf: any)

          public toString(): any
        }

        class Group {
          constructor(fields: any)

          public toString(): any
        }

        class Having {
          constructor(conditions: any)

          public toString(): any
        }

        class Join {
          constructor(right: any, conditions: any, side: any, mode: any)

          public toString(): any
        }

        class Limit {
          constructor(value: any, offset: any)

          public toString(): any
        }

        class ListValue {
          constructor(value: any)

          public toString(): any
        }

        class LiteralValue {
          constructor(value: any, value2: any)

          public toString(): any
        }

        class NumberValue {
          constructor(value: any)

          public toString(): any
        }

        class Offset {
          constructor(row_count: any, limit: any)

          public toString(): any
        }

        class Op {
          constructor(operation: any, left: any, right: any)

          public toString(): any
        }

        class Order {
          constructor(orderings: any, offset: any)

          public toString(): any
        }

        class OrderArgument {
          constructor(value: any, direction: any)

          public toString(): any
        }

        class ParameterValue {
          constructor(value: any)

          public toString(): any
        }

        class Select {
          constructor(fields: any, source: any, distinct: any, joins: any, unions: any)

          public toString(): any
        }

        class Star {
          constructor()

          public toString(): any
        }

        class StringValue {
          constructor(value: any, quoteType: any)

          public toString(): any
        }

        class SubSelect {
          constructor(select: any, name: any)

          public toString(): any
        }

        class Table {
          constructor(name: any, alias: any, win: any, winFn: any, winArg: any)

          public toString(): any
        }

        class UnaryOp {
          constructor(operator: any, operand: any)

          public toString(): any
        }

        class Union {
          constructor(query: any, all: any)

          public toString(): any
        }

        class Where {
          constructor(conditions: any)

          public toString(): any
        }
      }
    }
  }
}
